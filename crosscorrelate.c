#include <stdio.h>
#include <stdlib.h>
#include <math.h>
/* 

   fourier based cross correlation

 */

#define COMP_PRECISION double
#define MEMERROR {fprintf(stderr,"memory allocation error\n");exit(-1);}

void four1(COMP_PRECISION *,unsigned long ,int );
void realft(COMP_PRECISION *,unsigned long,int );
void twofft(COMP_PRECISION *,COMP_PRECISION *,
	    COMP_PRECISION *,COMP_PRECISION *,unsigned long );
void correl(COMP_PRECISION *,COMP_PRECISION *,
	    unsigned long ,COMP_PRECISION *);
int pwrtwo(int );

int main(int argc,char **argv)
{
  COMP_PRECISION tmp,lag,dx,*x,*y1,*y2,pf=0.;
  FILE *in;
  int i,n,n2,pad;
  if(argc<3||argc>4){
    fprintf(stderr,"%s file1 file2 [padding, %g]\nreads in two x y datafiles as generated by resample\n",
	    argv[0],pf);
    fprintf(stderr,"\tboth need to have the same number of 2^n samples, n=1,2...\n");
    fprintf(stderr,"\tx values should run from 0 to the same xmax in even dx spacings\n");
    fprintf(stderr,"\tcalculates cross correlation function\n");
    fprintf(stderr,"padding is the fraction of n to use for zero padding\n");
    exit(-1);
  }
  if(argc==4)
    sscanf(argv[3],"%lf",&pf);
  // read in data from file 1
  x=(COMP_PRECISION *)malloc(sizeof(COMP_PRECISION));
  y1=(COMP_PRECISION *)malloc(sizeof(COMP_PRECISION));
  n=0;
  in=fopen(argv[1],"r");
  if(!in){fprintf(stderr,"can not open file 1: %s\n",argv[1]);exit(-1);}
  while(fscanf(in,"%lf %lf",(x+n),(y1+n))==2){
    n++;
    x=(COMP_PRECISION *)realloc(x,(n+1)*sizeof(COMP_PRECISION));
    y1=(COMP_PRECISION *)realloc(y1,(n+1)*sizeof(COMP_PRECISION));
    if(!x || !y1)MEMERROR;
  }
  fclose(in);
  if(!pwrtwo(n)){
    fprintf(stderr,"file 1, read %i records, not power of 2\n",n);
    exit(-1);
  }else{
    fprintf(stderr,"read %i records from file 1, %s\n",
	    n,argv[1]);
  }
  // length of 'data', ie. with zero padding
  pad=(int)(pf*(COMP_PRECISION)n)-1;
  if(pad+1){
    fprintf(stderr,"attempted padding of %i at each side (pf: %g of %i)\n",
	    pad+1,pf,n);
    do{
      pad++;
      n2=n+2*pad;
    }while(!pwrtwo(n2));
    fprintf(stderr,"actually using %i padding at each side\n",
	    pad);
  }else{
    pad++;
    n2=n;
  }
  // rescale to be used as work array
  x=(COMP_PRECISION *)realloc(x,2*n2*sizeof(COMP_PRECISION));
  if(!x)MEMERROR;
  // rescale to allow for padding
  y1=(COMP_PRECISION *)realloc(y1,n2*sizeof(COMP_PRECISION));
  if(!y1)
    MEMERROR;
  // second data set
  y2=(COMP_PRECISION *)malloc(n2*sizeof(COMP_PRECISION));
  if(!y2)
    MEMERROR;
  if(x[0] != 0){
    fprintf(stderr,"file 1, x values should start with zero\n");exit(-1);
  }
  dx=x[1]-x[0];
  for(i=2;i<n;i++)
    if((fabs((x[i]-x[i-1]-dx)/dx)>0.01) || (x[i]<=x[i-1])){
      fprintf(stderr,"need even sorted spacing in x, file 1, entry %i and %i, dx: %g spacing: %g\n",
	      i+1,i,dx,x[i]-x[i-1]);
      exit(-1);
    }
  dx=(x[n-1]-x[0])/n;
  in=fopen(argv[2],"r");
  if(!in){fprintf(stderr,"can not open file 2: %s\n",argv[2]);exit(-1);}
  for(i=0;i<n;i++){
    if(fscanf(in,"%lf %lf",&tmp,(y2+i))!=2){
      fprintf(stderr,"read error file 2, entry %i\n",i+1);
      exit(-1);
    }
    if(tmp != x[i]){
      fprintf(stderr,"x value mismatch, entry %i, file 1: %g, file 2: %g\n",
	      i+1,x[i],tmp);
      exit(-1);
    }
  } 
  fclose(in);
  fprintf(stderr,"read in equivalent %i points from %s\n",n,argv[2]);

 
  for(i=0;i<n;i++)
    x[i]=y1[i];
  for(i=0;i<pad;i++)   y1[i]=0.0;
  for(i=pad;i<pad+n;i++)y1[i]=x[i-pad];
  for(i=pad+n;i<n2;i++)y1[i]=0.0;

  for(i=0;i<n;i++)
    x[i]=y2[i];
  for(i=0;i<pad;i++)    y2[i]=0.0;
  for(i=pad;i<pad+n;i++)y2[i]=x[i-pad];
  for(i=pad+n;i<n2;i++) y2[i]=0.0;
  correl(y1-1,y2-1,(unsigned long)n2,x-1);
  // negative lags
  for(lag=-n2/2.*dx,i=n2/2;i<n2;i++,lag+=dx)
    printf("%g %g\n",lag,x[i]/n2);
  // zero up to positive lags
  for(lag=0.0,i=0;i<n2/2;i++,lag+=dx)
    printf("%g %g\n",lag,x[i]/n2);
  return 0;
}
void correl(COMP_PRECISION *data1,COMP_PRECISION *data2,
	    unsigned long n,COMP_PRECISION *ans)
{
  unsigned long no2,i;
  COMP_PRECISION dum,*fft;
  fft=(COMP_PRECISION *)malloc(sizeof(COMP_PRECISION)*((n<<1)+1));
  if(!fft)MEMERROR;
  twofft(data1,data2,fft,ans,n);
  no2=n>>1;
  for (i=2;i<=n+2;i+=2) {
    ans[i-1]=(fft[i-1]*(dum=ans[i-1])+fft[i]*ans[i])/no2;
    ans[i]=(fft[i]*dum-fft[i-1]*ans[i])/no2;
  }
  ans[2]=ans[n+1];
  realft(ans,n,-1);
  free(fft);
}

void twofft(COMP_PRECISION *data1,COMP_PRECISION *data2,
	    COMP_PRECISION *fft1,
	    COMP_PRECISION *fft2,
	    unsigned long n)
{
  unsigned long nn3,nn2,jj,j;
  COMP_PRECISION rep,rem,aip,aim;
  
  nn3=1+(nn2=2+n+n);
  for (j=1,jj=2;j<=n;j++,jj+=2) {
    fft1[jj-1]=data1[j];
    fft1[jj]=data2[j];
  }
  four1(fft1,n,1);
  fft2[1]=fft1[2];
  fft1[2]=fft2[2]=0.0;
  for (j=3;j<=n+1;j+=2) {
    rep=0.5*(fft1[j]+fft1[nn2-j]);
    rem=0.5*(fft1[j]-fft1[nn2-j]);
    aip=0.5*(fft1[j+1]+fft1[nn3-j]);
    aim=0.5*(fft1[j+1]-fft1[nn3-j]);
    fft1[j]=rep;
    fft1[j+1]=aim;
    fft1[nn2-j]=rep;
    fft1[nn3-j] = -aim;
    fft2[j]=aip;
    fft2[j+1] = -rem;
    fft2[nn2-j]=aip;
    fft2[nn3-j]=rem;
  }
}
void realft(COMP_PRECISION *data,unsigned long n,int isign)
{
  unsigned long i,i1,i2,i3,i4,np3;
  COMP_PRECISION c1=0.5,c2,h1r,h1i,h2r,h2i;
  double wr,wi,wpr,wpi,wtemp,theta;

  theta=3.141592653589793/(double) (n>>1);
  if (isign == 1) {
    c2 = -0.5;
    four1(data,n>>1,1);
  } else {
    c2=0.5;
    theta = -theta;
  }
  wtemp=sin(0.5*theta);
  wpr = -2.0*wtemp*wtemp;
  wpi=sin(theta);
  wr=1.0+wpr;
  wi=wpi;
  np3=n+3;
  for (i=2;i<=(n>>2);i++) {
    i4=1+(i3=np3-(i2=1+(i1=i+i-1)));
    h1r=c1*(data[i1]+data[i3]);
    h1i=c1*(data[i2]-data[i4]);
    h2r = -c2*(data[i2]+data[i4]);
    h2i=c2*(data[i1]-data[i3]);
    data[i1]=h1r+wr*h2r-wi*h2i;
    data[i2]=h1i+wr*h2i+wi*h2r;
    data[i3]=h1r-wr*h2r+wi*h2i;
    data[i4] = -h1i+wr*h2i+wi*h2r;
    wr=(wtemp=wr)*wpr-wi*wpi+wr;
    wi=wi*wpr+wtemp*wpi+wi;
  }
  if (isign == 1) {
    data[1] = (h1r=data[1])+data[2];
    data[2] = h1r-data[2];
  } else {
    data[1]=c1*((h1r=data[1])+data[2]);
    data[2]=c1*(h1r-data[2]);
    four1(data,n>>1,-1);
  }
}

#define NUMREC_SWAP(a,b) tempr=(a);(a)=(b);(b)=tempr

void four1(COMP_PRECISION *data,unsigned long nn,int isign)
{
  unsigned long n,mmax,m,j,istep,i;
  double wtemp,wr,wpr,wpi,wi,theta;
  COMP_PRECISION tempr,tempi;

  n=nn << 1;
  j=1;
  for (i=1;i<n;i+=2) {
    if (j > i) {
      NUMREC_SWAP(data[j],data[i]);
      NUMREC_SWAP(data[j+1],data[i+1]);
    }
    m=n >> 1;
    while (m >= 2 && j > m) {
      j -= m;
      m >>= 1;
    }
    j += m;
  }
  mmax=2;
  while (n > mmax) {
    istep=mmax << 1;
    theta=isign*(6.28318530717959/mmax);
    wtemp=sin(0.5*theta);
    wpr = -2.0*wtemp*wtemp;
    wpi=sin(theta);
    wr=1.0;
    wi=0.0;
    for (m=1;m<mmax;m+=2) {
      for (i=m;i<=n;i+=istep) {
	j=i+mmax;
	tempr=wr*data[j]-wi*data[j+1];
	tempi=wr*data[j+1]+wi*data[j];
	data[j]=data[i]-tempr;
	data[j+1]=data[i+1]-tempi;
	data[i] += tempr;
	data[i+1] += tempi;
      }
      wr=(wtemp=wr)*wpr-wi*wpi+wr;
      wi=wi*wpr+wtemp*wpi+wi;
    }
    mmax=istep;
  }
}
#undef NUMREC_SWAP

int pwrtwo(int i)
{
  COMP_PRECISION tmp;
  tmp=log((COMP_PRECISION)i)/0.693147180559945318;
  if(fabs(tmp-(COMP_PRECISION)((int)tmp))>1.0e-7)
    return 0;
  else
    return 1;

}
